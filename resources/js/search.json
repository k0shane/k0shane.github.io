[[{"l":"Profile","p":["Knowledge that isn't applied is wasted, isn't it?","So I made this blog to share all the things that I'm working on."]},{"i":"cuserswhoami","l":"C:\\users\\whoami>","p":["I am just a techie, working as a penetration tester / red teamer. Interesting in both offensive and defensive. Passionate in window exploit development, evasion AV, EDRs , Reverse Engineering, Binary Exploitation and Active Directory."]},{"i":"cusersarchievements","l":"C:\\users\\archievements>"}],[{"i":"how-i-get-1500-bounty-with-idor-to-account-takeover","l":"How I get 1500$ bounty with IDOR to Account Takeover","p":["Back in 2022, I didn't get a job yet at that time. So I just doing full time bug bounty hunting and got a couple of bounties from hackerone and zerocopter. One day I saw a fresh program in zerocopter by searching with google dorks, I think no one hunt it yet on this program except their internal pentest team. There are no other subdomains and only one domain is in scope. So I quickly grab the link and make an account.","After creating account, I go to my profile and it look like this.","I noticed that we have our own userID, it look like unique ID. And we can edit our profile such as firstName, lastName and Email. So I intercept edit profile endpoint with burp and the request look like this.","By looking this request, the first thing in my mind was IDOR. So before thinking about possible or not as per their unique ID, I create another account and grab the userID.","And click on edit profile and intercept again with brup. Then I replaced with another userID with the current userID.The request will be like this.","Replace userID:","Request Body:","Fortunately, it was changed the name and email of another user's account. To be honest, I really did not expect that cuz in their responsible disclosure page, they already mentioned that they have their own internal team to test their website. So this kind of bug should be aware.","Now the problem is how can we get that kind of unique ID? Then I found one endpoint that disclosing that userID which in Billing Admins tab. In this tab, we can invite another member. So after the user accepted our invite we can see like this.","If we click on member account, we can see their profile including their unquieID.","So to get the userID, the user must be in our team or otherwise we have to invite them. If we get their ID, we can change their email which will lead to account takeover. Then I quickly create the POC and report it. After one day, the issue has been verified and they reward me 4 digit bounty which I wasn't expect xD."]}],[{"l":"0x0 Intro to Binary Exploitation","p":["Before diving into binary exploitation, let’s get our environment ready. I’ll be using Kali Linux, but you can go with Ubuntu or any other Linux distro. First, install gdb with sudo apt install gdb. Next, set up the pwndbg plugin for much easier debugging experience. You can find it here: https://github.com/pwndbg/pwndbg","Our first program will be like below:","You can compile with this command to get binary file. gcc overflow.c -o overflow -fstack-protector-all.","The program is straightforward.It takes an input from the user with 20 buffer size. The problem is gets function which cause buffer overflow because it does not check the size of our buffer. So if the user input more data than the buffer can hold, it can overflow and overwrite critical data like return addresses."]}],[{"l":"Attacking Json Web Token","p":["Let's say, this is a normal user web page.","When we register and login with an account, the authentication mechanism is look like this.","When we decode it,","It's using RS256 algorithm and token is using jku header parameter which contains the JSON Web Key and the URL is to be used for token verification.","The jku header is a URI that refers to a resource for a set of JSON-encoded public keys, one of which corresponds to the key used to digitally sign the JWS.","The jku header url is look like this,","If an attacker generate a public and private key pairs and create a new token with a new private key (which we generated) and replace jku header with the url which contains new generated jwks.json file (host on a web server) and then the token would be accept by the server.","Download or copy that jwks.json file."]},{"i":"creating-a-new-keypairpem","l":"Creating a new keypair.pem"},{"i":"generating-nekid","l":"Generating n,e,kid","p":["We're using python jwcrypto module to generate n,e and kid","Install pip3 install jwcrypto","Run python3 jwk-gen-1.py and the output should look like this.","Replace kid, n and e in your jwks.json file.","Now we can create a new token as username admin"]},{"l":"Creating new token","p":["If the server validate the original url, we can use the Redirect method like above. If not, you can use just like jku: http://yourwebsever.com/jwks.json","Run that script and we will get a new token like this.","Now create a web server, copy that a new token and replace it in a cookie header in web page.","When we replace the token and refresh page, it will request/download jwks.json file in our web server.","Now we got admin panel by jku header claiming method."]}],[{"l":"0x00 Stack Base Buffer Overflow","p":["I won't talk about details in here like how the stack work or what are registers. You must have first knowledge in basic assembly language and debugger because I intended this blog for practical purpose, so I don't wanna make you bored for reading this kind of stuff. If you don't know yet how the stack work, there are plenty of good resources out there.I recommend to read it first. So Let's cut to the chase."]},{"i":"what-is-buffer-overflow","l":"What is buffer overflow?","p":["Buffer Overflow may happen when a program writes more data to a buffer (user inputs) beyond it can hold. This will lead to memory corruption which mean our buffer can overwrite some important datas of the program in memory. With this vulnerability, attacker can make the program do things it wasn't supported to do, like running malicious code. This kind of vulnerabilities may happen in programming languages like C and C++ due to their low-level memory management and lack protection. For other languages like Java has automatic memory management through the Garbage Collector. It takes care of allocating and freeing memory, reducing the risk of buffer overflows.","Think of a login form that ask us to input username and the developer set the username field with a maximum length 10 characters. But if we enter 50 or 100 characters, the extra data migth overwrite into the other parts of the program (EIP),and it will be break the program. So instead of breaking the program, we can control the EIP(Instruction Pointer which hold the memory address of the next execution), we can redirect the execution of our program wherever we want. For example, redirect to our injected malicious shellcode location."]},{"l":"Intro","p":["For the first of this series, we gonna use CloudMe Sync 1.11.0 application to develop our exploit. This application is vulnerable to Remote Buffer Overflow on port 8888.","For the requirements, I used windows 7, Immunity Debugger and python3.","When we open the app, it will running on port 8888 in the background. We can check with netstat -ano command.","Before we get started, we need to attach our app with immunity debugger, so we can see how the application is working in the background and all the instruction. Run cloudme application first, and in immunity debugger, click on File Attach."]},{"l":"Fuzzing","p":["Now for the first step, we need to identify how many buffer the application can handle, how many buffer we need to overwrite EIP or crash the application. let's run our fuzzing script below.","When we run the script, we can see that the application did not crash.","But it was overwritten in our EIP with 41414141 which is A character in hex, we can check and see in debugger. Now we know the program is vulnerable to buffer overflow.","We need to know the exact location of the buffer to overwrite EIP address. So we can put the address of our shellcode location into EIP and redirect the program to execute it."]},{"l":"Finding the Offset","p":["From above scenario, we used only AAAA which is repetitive data to overflow the program. The problem is that it doesn't help us to locate the exact point of overflow, as we can't distinguish one \"A\" from another in the memory dump.","So to archive this, we will use usr/bin/msf-pattern_create -l 5000 tool to generate non-repeating string from msf.Or we can easily use online generator tool in here","Update our tool with generated pattern.","Now restart debugger and run the script again.","We can see that our ESP is also overflow with our pattern. For now copy EIP address and check with patter_offset from msf."]},{"l":"Controlling EIP","p":["Now we know that we need 1052 buffer to control EIP. Let's update our code with this offset and put BBBB as EIP to make sure this will actually overwrite EIP or not.","Run the script again.","See! our EIP was overwritten by 42424242 which are BBBB in hex.","Now we know we can control EIP address which mean we can redirect the application's execution wherever we want (not wherever xD, will see).","For pointing EIP to our shellcode's location, we have to use a method called jump + reg. And our shellcode is overflowing on the stack, so we can use jmp esp instruction.","So, the flow will be like this, we will use jmp esp to jump on this stack which will be our shellcode location and execute it.","Before we finding that instruction, we need to find bad characters."]},{"l":"Finding Bad Characters","p":["What are bad characters actually? When we exploiting buffer overflow, we need to inject a playload like shellcode into the memory of our target program. But certain characters contain in the shellcode may break our payload like 0x00(null byte) or 0x0A(new lines) which are use to terminate the strings.","When our payload include these characters, it may not working as intended and causing the exploit fail. So how can we find bad characters?","To identify bad characters, we need to send all the possible byte values 0x00 ot 0xFF(like above we sent junk code) by using debugger, then check for any characters that break our payload.","So, stop talking and let's see the demostration.","We can generate bad characters byte array using !mona bytearray command. It will store two file in current working directory, bytearray.txt and bytearray.bin. You can set mona's current working directory with this command !mona config -set workingfolder c:\\mona","Copy all the bytes and put it into our exploit.","Run the script again.","Now we can see our ESP is overwritten by junk data, value is 0028D470. Right click on it and Follow in Dump to see in the dump window. We can also check manually but in this case we gonna use mona command which is !mona compare -f C:\\Program Files (x86)\\Immunity Inc\\Immunity Debugger\\bytearray.bin -a 0028D470 for automate task. If we have bad charaters, it will show all in the BadChars field.","In this case, we don't actually have any bad characters. Great!"]},{"l":"Identify JMP Instruction","p":["Let's continue our exploit. Now we need to identity jump instruction in the modules dll or similar component cloueme.exe which are lack memory protection. We can use !mona modules command to accomplish this.","You can see Qt5Core.dll has False on every protection. We will use this one. So to find our jmp esp instruction inside that dll, we have to use opcode. To accomplish this, we can use mfs moudule called nasm_shell.rb.","Okay the opcode for jmp esp is FF E4. Now let check this opcode is available or not inside our Qt5Core.dll using this command !mona find -s \\xff\\xe4 -m Qt5Core.dll","Choose whatever address you want but you should avoid chosing the address that include null bytes 00, otherwise it may break our exploit. I will choose this address 0x68BAD568 in this case.","Okay, now let see what we've got here.","We have EIP's offset which is 1052.","We've also identified bad characters, which was none in this case.","Then we've found an application's dll module which doesn't has any protection.","And we've also got the jmp esp instruction address inside that dll."]},{"l":"Exploiting","p":["Now it time to generate our shellcode with msfvenom. I will use calc.exe for this scenario.","So our full exploit will be like below.","You may noticted, NOP in this code. NOP (No Operation) instruction tells the processor to do nothing. It's like a placeholder in code, where no action is required, but the program continues to run.","So why do we need this? If the program's execution jumps to any of the NOPs, it will \"slide\" down the sled until it hits the shellcode and executes it. This makes our exploit more likely to work, even if the return address isn’t perfectly accurate.","Without a NOP sled, you would have to pinpoint the exact starting address of the shellcode, which is hard and unreliable for our exploit.","If we run this, it will pop up calculator. That's it. You can test with your own meterpreter shellcode."]}],[{"l":"0x01 SEH Base Buffer Overflow"}]]